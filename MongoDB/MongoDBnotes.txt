Date:13/7/2022
MongoDB-->
2 types of DB
1.Relational Data Base Management(RDBMs)-->
  Schema-- optimized for storing structured data
             for know the exact business requirement
follows -ACID
2.NO SQL--> variable(future) business requirement
         Databases-->   MongoDB,Elastic search,Dynamo,Caosando,Redis
  MongoDB 4 types of store DB
  1.Document -- is stored in JSON
  2.wide-Column
  3.Key/Value
  4.Graph DB  
  MongoDB follows--CAP(Consistency,Avilability,Partition tolerance)
  *Schemaless
  *Replication of data
  *
 MongDB ecosystem--
 commands-->
 1.show dbs;
 How to create db?
 use testDB;
 db is object instace similar to  the "this" k/w in oops.
 db is point to current connected database.
  *Creating documents 3methods-->
   insert(...),insertOne({}),insertMany([{},{},{},...])
  *Read documents using-->find(),findOne()
  *Update documents using-->updateOne(),updateMany(),replaceOne()
  *Delete documents using-->deleteOne(),deleteMany()
 db.products.insertOne({}) //products is collection name


  db.products.insertOne({"name":"IPhone 12","cost":400})
  db.products.insertOne({"name":"Mac","cost":600,"details":{"cpu":"i7 4783","ram":32}});// id is autogenerated
  db.products.insert([{"name":"A","cost":700},{name:"B",cost:4567}]);
   db.products.find()
   db.products.find().pretty()
  db.products.insertMany([{"name":"Mi 4","cost":700},{name:"IPhone 4",cost:4567}]);// id is autogenerated
  db.products.insert([{"name":"A","cost":700},{name:"B",cost:4567}]);//id is not generated

db.products.find({name:"Mi 4"})
 db.products.find({cost:{$gt:500}}).pretty()
  db.products.findOne({cost:{$gt:500}})
 db.products.deleteOne({_id: ObjectId("62cedbf101267aee6bf1da27")})
db.products.updateOne({_id: ObjectId("62ceb33801267aee6bf1da20")},{$set:{name:"samsung-galaxy"}})
db.products.updateOne({_id: ObjectId("62ceb33801267aee6bf1da20")},{$set:{name:"samsung-galaxy",soldIn:["India","US"]}})

Reference
{
  "name":"IPhone 12","cost":400
}
 {
   "name":"Mac Book Pro","cost": 130.13,"details":{"cpu":i7 4783,"ram":32}
 }

* MongoDB auto generating the _id(reserved key)
 we can manually add id also
 db.products.insertOne({_id:100,"name":"Mi 4","cost":700});

Application:
UI -> BackEnd -> Drivers ===> DataBase(Server->storage engine->data)
                   |
                   V
                  Node/Java/Python 


docs.mongodb.com/drivers/node/current/fundamentals/crud

JSON < BSON(Binary version of key-value pair)
for showing record--
db.products.find().count()

Date:14/7/2022
========2=======================
For import file 
open cmd -->
set path="c:\Program Files\MongoDB\Tools\100\bin"
set path="c:\Program Files\MongoDB\Server\5.0\bin"
mongoimport (command line utility -- have to download)
mongoimport tv-shows.json -d MoviesDB -c movies --jsonArray --drop
meaning of drop --> drop the collection and recreate it
mongoimport tv-show.json -d MoviesDB -c movies --jsonArray --drop
 db.movies.find().count()

for filtering data-->
docs.mongodb.com/manual/tutorial/query-documents/
docs.mongodb.com/manual/reference/operator/query-logical/

For quering data needs-->
Methods -- like find(),Filters,Operator
opertors--> $eq,$ne,$gt,$gte,$lte
db.movies.find({runtime:{$eq:60}}).count()
db.movies.find({runtime:{$ne:60}}).count()

navigate to embedded query
db.movies.find({"network.country.code":"US"}).count()
 db.movies.find({genres:"Drama"}).count()
 db.movies.find({genres:["Drama"]}).count()
 db.movies.find({genres:"Drama",genres:"Horror"}).count()

logical operator-->
 db.movies.find({$or:[{"rating.average":{$lt:5}},{"rating.average":{$gt:9.3}}]}).count()
db.movies.find({"rating.average":{$gt:9},genres:"Drama"}).count()
 db.movies.find({$and:[{"rating.average":{$gt:9}},{genres:"Drama"}]}).count()

===
db.movies.find({genres:"Drama",genres:"Horror"}).count()// first column count replaced
by 2nd col
23
db.movies.find({$and:[{genres:"Drama"},{genres:"Horror"}]}).count()
17
db.movies.find({genres:"Horror"}).count()//
23
==
db.movies.find({runtime:{$in:[30,42]}}).count()
63
 db.movies.find({runtime:{$nin:[30,42]}}).count()
177

=======Date:15/7/2022=====
show collections
db.movies.find({"rating.average":9}).count()
To check the existence of specific field use exists
db.movies.find({"rating.average":{$exists:true}}).count()

 db.users.find({phone:{$type:"number"}}).pretty()
db.users.find({phone:{$type:["double","string"]}}).pretty()

 db.users.find({"phone":{$exists:true}}).pretty()
 db.users.find({"phone":{$exists:false}}).pretty()
 $regex -- pattern matching
  db.movies.find({summary:{$regex:/drama/}}).pretty()
db.sales.insertMany([{"volume":100,"target":120},{"volume":80,"target":89},{"volume":200,"target":178}])

$expr--
db.sales.find({$expr:{$gt:["$volume","$target"]}}).pretty()
Update--
db.users.updateOne({_id: ObjectId("62d11b8607cfecaafd3ac655")},{$set:{hobbies:[{title:"Sports",frequency:4}]}})
db.users.updateOne({_id: ObjectId("62d11b8607cfecaafd3ac655")},{$set:{hobbies:[{title:"Sports",frequency:2},{title:"Playing",frequency:7}]}})
 db.users.updateMany({"hobbies.title":"Sports"},{$set:{isSporty:true}})
$min,$max
db.users.updateOne({name:"Max"},{$inc:{age:1},$set:{phone:9999999999}})
db.users.updateOne({name:"Max"},{$inc:{age:-5},$set:{phone:9999999999}})
 db.users.updateOne({name:"Max"},{$min:{age:20}})
db.users.updateOne({name:"Max"},{$max:{age:26}})
$mul
db.users.updateOne({name:"Max"},{$mul:{age:1.1}})
$rename
 db.users.updateMany({},{$rename:{name:"username"}})
$unset
 db.users.updateOne({_id: ObjectId("62d1205507cfecaafd3ac656")},{$unset:{phone:""}})

$upsert
 db.users.updateOne({"username":"Joel"},{$set:{age:29,isSporty:true,hobbies:[{title:"Sports",frequency:2},{title:"Chess",frequency:7}]}},{upsert:true})

db.users.deleteMany({})
db.users.deleteOne({username:"Joel"})
db.users.drop()

** Projection --> selecting limited number of fields
 db.users.find({},{username:1}).pretty()
 db.users.find({},{username:1,age:1,_id:0})
**Designing data model for Mongodb --2approaches
1.To store data in single document
2.To store data in multiple documents about specific entity
embedded concepts :: one-to-one cases
reference concepts:: one-to-many cases
which data is your application required?
Is there a schema to store data in Mongodb?

=====19/7/2022==============
Security considerations-->
   Authentication-- valid users connected to DB and Authorization--
   Encryption at rest
   Auditing
   Backups and software updates
   Encryption during transportation
*encryption protocol -->open ssl
 db.createUser({user:"user1",pwd:"password_123",roles:["userAdminAnyDatabase"]})
 db.createUser({user:"user2",pwd:"password_123",roles:["readWrite",{role:"readWrite",db:"MoviesDB"}]})
 db.logout()
 db.auth('user2','password_123')
**Influence performance--> use : Efficient Querying,Indexes,sharding-->partition of data,Replica set(replication of data)is a solution to our fault tolerance

*Geo Spatial data-->
store location details in Longitude(|) and Lattitude(__) on map 1st lattitude is showing
db.places.insertOne({name:"CitiusTech",location:{type:"Point",coordinates:[73.00458341896137,19.160497452990562]}})
db.places.insertOne({name:"LTI",location:{type:"Point",coordinates:[73.00128966650627,19.16007180389174]}})
db.places.insertOne({name:"Wipro",location:{type:"Point",coordinates:[ 73.0028346187979,19.160213687046763]}})

Find places near me at certain distance
I am at Airoli Station FOB  73.00005585044,19.159129291263007
$near --> createIndex first

db.places.createIndex({location:"2dsphere"})

db.places.find({location:{$near:{$geometry:{type:"Point",coordinates:[73.00005585044,19.159129291263007]},$maxDistance:200,$minDistance:10}}}).pretty()


type:"restaurant" or type:"IT Company"
 
======20/7/2022========
//mindspace Airoli
const p1=[72.999895,19.162909]
const p2=[73.00469053912056,19.163953255599576]
const p3=[73.005285,19.159607]
const p4=[73.000103,19.158899]

db.places.find({location:{$geoWithin:{$geometry:{type:"Polygon",coordinates:[[p1,p2,p3,p4,p1]]}}}}).pretty()

db.areas.insertOne({name:"Mindspace,Airoli",area:{type:"Polygon",coordinates:[[p1,p2,p3,p4,p1]]}})
db.areas.createIndex({area:"2dsphere"})



..........
Aggregation Framework
$match
db.persons.aggregate([
     {$match: {gender:'female'}}]).pretty();
........
$group
db.persons.aggregate([
    {$match: {gender:'female'}},
    {$group: {_id: {state: "$location.state"},totalPersons: {$sum:1}}}
]).pretty(); //state and totalpersons are not the field of schema when we grouping 
             // that time we have to start with _id(for navigating with documents) but here group of $location.state
             //'$' represents value otherwise without '$' it is represented key

.........
$sort
db.persons.aggregate([
     {$match: {gender:'female'}},  
     {$group: { _id:{state:"$location.state"},totalPersons:{$sum:1}}},
     {$sort:{totalPersons:-1}}
 ]).pretty();
...... 

$project $concat
db.persons.aggregate([
      { 
        $project:{
          _id:0,
          gender:1,
          fullName:{$concat:["$name.first","","$name.last"]
           } 
        }
      }
  ]).pretty();
......
$project $concat $toUpper
db.persons.aggregate([
  {  
     $project:{
          _id:0,
          gender:1,
          fullName:{$concat:[
                 {$toUpper:"$name.first"},"",{$toUpper:"$name.last"}]
                 }
              }
  }
]).pretty()

..............................................
$project
db.persons.aggregate([{$project:{_id:0,gender:1,fullName:{$concat:[{$toUpper:{$substrCP:['$name.first',0,1]}},{$substrCP:['$name.first',1,{$substract:[{$strLenCP:'$name.first'},1]}]},'',{$toUpper:{$substrCP:['$name.last',0,1]}},{$substrCP:['$name.last',1,{$subtract:[{$strLenCP:'$name.last'},1]}]}]}}}])

.......
db.persons.aggregate([
          {$match:{gender:'female'}},
          {$out:"femalePersons"}   //$out should be last stage and it creates separate collection

]).pretty()


...........................
Transactions--
group the set of commands together as a single unit(as a successsfully or failed at a single unit)


==============================================================
19/10 --
 1.show dbs
 2.use DBNAME  --it will create the db or if alredy exist then s/w to that db
 3.show collections  -- it shows tables
 4.db.createCollection('TBNAME') 
 5.show collections
 6.db.TBNAME.insertOne({name:"Manu",email:"manu@gmail.com"})
 7.db.TBNAME.find({}) -- it works like SELECT query
 8.db.TBNAME.find({name:"Manu"})
 9.db.TBNAME.updateOne({name:"Manu"},{$set:{name:Mina})
 10.db.TBNAME.deleteOne({name:"Manu"})
npm install express mongoose